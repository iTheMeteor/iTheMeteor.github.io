<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LeetCode每日一题2021.1.3</title>
    <url>/2021/01/03/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982021-1-3/</url>
    <content><![CDATA[<h1 id="2021-01-03"><a href="#2021-01-03" class="headerlink" title="2021.01.03"></a>2021.01.03</h1><p><a href="https://leetcode.com/problems/partition-list/"><strong>86. Partition List [Medium]</strong></a> </p>
<blockquote>
<p>Given a linked list and a value <em>x</em>, partition it such that all nodes less than <em>x</em> come before nodes greater than or equal to <em>x</em>.</p>
<p>You should preserve the original relative order of the nodes in each of the two partitions.</p>
<p><strong>Example:</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Input: head = <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span>-&gt;<span class="number">2</span>, x = <span class="number">3</span></span><br><span class="line">Output: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">5</span></span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<p>毫无营养的送分题，直观来说我们只需维护两个链表left 和 right 即可，left 链表按顺序存储所有小于 x 的节点，right 链表按顺序存储所有大于等于 x 的节点。遍历完原链表后，我们只要将 left 链表尾节点指向 right 链表的头节点即能完成对链表的分隔。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        ListNode *left=<span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode *right=<span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode *l=left,*r=right;</span><br><span class="line">        <span class="keyword">for</span>(ListNode * p=head;p;p=p-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;val&lt;x) l=l-&gt;next=p;</span><br><span class="line">            <span class="keyword">else</span> r=r-&gt;next=p;</span><br><span class="line">        &#125;</span><br><span class="line">        r-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        l-&gt;next=right-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> left-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode每日一题2021.1.1</title>
    <url>/2021/01/01/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982021-1-1/</url>
    <content><![CDATA[<h1 id="2021-01-01"><a href="#2021-01-01" class="headerlink" title="2021.01.01"></a>2021.01.01</h1><p><a href="https://leetcode.com/problems/can-place-flowers/"><strong>605、Can Place Flowers [Easy]</strong> </a> </p>
<blockquote>
<p>You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.<br>Given an integer array flowerbed containing 0’s and 1’s, where 0 means empty and 1 means not empty, and an integer n, return if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&gt;Input: flowerbed = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>], n = <span class="number">1</span></span><br><span class="line">&gt;Output: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<p>本题感觉还是比较简单的，一开始卡在对边界条件的处理上，想了很久发现可以直接在开头和结尾都加上0，这样处理的就不用考虑边界条件，任意位置处只要连续出现三个 0 就可以栽上一棵花。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPlaceFlowers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; flowerbed, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        flowerbed.insert(flowerbed.begin(),<span class="number">0</span>);</span><br><span class="line">        flowerbed.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> len=flowerbed.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flowerbed[i<span class="number">-1</span>]==<span class="number">0</span>&amp;&amp;flowerbed[i]==<span class="number">0</span>&amp;&amp;flowerbed[i+<span class="number">1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">                flowerbed[i]=<span class="number">1</span>;</span><br><span class="line">                n--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(n==<span class="number">0</span>)	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode每日一题2021.1.5</title>
    <url>/2021/01/05/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982021-1-5/</url>
    <content><![CDATA[<h1 id="2021-01-05"><a href="#2021-01-05" class="headerlink" title="2021.01.05"></a>2021.01.05</h1><p><a href="https://leetcode.com/problems/positions-of-large-groups/"><strong>830. Positions of Large Groups [Easy]</strong></a> </p>
<blockquote>
<p>In a string <code>s</code> of lowercase letters, these letters form consecutive groups of the same character.</p>
<p>For example, a string like <code>s = &quot;abbxxxxzyy&quot;</code> has the groups <code>&quot;a&quot;</code>, <code>&quot;bb&quot;</code>, <code>&quot;xxxx&quot;</code>, <code>&quot;z&quot;</code>, and <code>&quot;yy&quot;</code>.</p>
<p>A group is identified by an interval <code>[start, end]</code>, where <code>start</code> and <code>end</code> denote the start and end indices (inclusive) of the group. In the above example, <code>&quot;xxxx&quot;</code> has the interval <code>[3,6]</code>.</p>
<p>A group is considered <strong>large</strong> if it has 3 or more characters.</p>
<p>Return <em>the intervals of every <strong>large</strong> group sorted in <strong>increasing order by start index</strong></em>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Input: s = <span class="string">&quot;abbxxxxzzy&quot;</span></span><br><span class="line">Output: [[<span class="number">3</span>,<span class="number">6</span>]]</span><br><span class="line">Explanation: <span class="string">&quot;xxxx&quot;</span> is the only large group with start index <span class="number">3</span> <span class="keyword">and</span> end index <span class="number">6.</span></span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<p>比较简单的一道题，这里用了两个循环</p>
<blockquote>
<p>for：负责处理外层逐字遍历。</p>
<p>while：负责处理“较大分组”遍历</p>
</blockquote>
<p>代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; largeGroupPositions(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; r &lt; s.size(); l = r) &#123; <span class="comment">// l = r 设置开始区间。左闭[</span></span><br><span class="line">            <span class="comment">// ++r指针刚好超“较大分组”一个位置。相当于左闭右开区间[)</span></span><br><span class="line">            <span class="keyword">while</span> (r &lt; s.size() &amp;&amp; s[l] == s[r]) ++r;</span><br><span class="line">            <span class="comment">// r - 1 刚好把超过的位置移回去。相当于2端闭区间[]。</span></span><br><span class="line">            <span class="keyword">if</span> (r - l &gt;= <span class="number">3</span>) result.push_back(&#123;l, r - <span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode每日一题2021.1.2</title>
    <url>/2021/01/02/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982021-1-2/</url>
    <content><![CDATA[<h1 id="2021-01-02"><a href="#2021-01-02" class="headerlink" title="2021.01.02"></a>2021.01.02</h1><p><a href="https://leetcode.com/problems/sliding-window-maximum/"><strong>239. Sliding Window Maximum [Hard]</strong></a> </p>
<blockquote>
<p>You are given an array of integers <code>nums</code>, there is a sliding window of size <code>k</code> which is moving from the very left of the array to the very right. You can only see the <code>k</code> numbers in the window. Each time the sliding window moves right by one position.</p>
<p>Return <em>the max sliding window</em>. </p>
<p><strong>Example 1:</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Input: nums = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">-1</span>,<span class="number">-3</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>], k = <span class="number">3</span></span><br><span class="line">Output: [<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">Explanation: </span><br><span class="line">Window position                Max</span><br><span class="line">---------------               -----</span><br><span class="line">[<span class="number">1</span>  <span class="number">3</span>  <span class="number">-1</span>] <span class="number">-3</span>  <span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">3</span></span><br><span class="line"> <span class="number">1</span>  [<span class="number">3</span>  <span class="number">-1</span>  <span class="number">-3</span>] <span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">3</span></span><br><span class="line"> <span class="number">1</span>   <span class="number">3</span> [<span class="number">-1</span>  <span class="number">-3</span>  <span class="number">5</span>] <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">5</span></span><br><span class="line"> <span class="number">1</span>   <span class="number">3</span>  <span class="number">-1</span> [<span class="number">-3</span>  <span class="number">5</span>  <span class="number">3</span>] <span class="number">6</span>  <span class="number">7</span>       <span class="number">5</span></span><br><span class="line"> <span class="number">1</span>   <span class="number">3</span>  <span class="number">-1</span>  <span class="number">-3</span> [<span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>] <span class="number">7</span>       <span class="number">6</span></span><br><span class="line"> <span class="number">1</span>   <span class="number">3</span>  <span class="number">-1</span>  <span class="number">-3</span>  <span class="number">5</span> [<span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>]      <span class="number">7</span></span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<p>这题是典型的滑动窗口问题，理解题目意思以后写起来问题不是很大，具体思路为：</p>
<blockquote>
<p>遍历数组，将数据存储在双向队列中，并用 L,R 来标记窗口的左边界和右边界。队列中保存的并不是真的数据，而是该数值对应的数组下标位置，并且数组中的数要从大到小排序。如果当前遍历的数比队尾的值大，则需要弹出队尾值，直到队列重新满足从大到小的要求。刚开始遍历时，L 和 R 都为 0，有一个形成窗口的过程，此过程没有最大值，L 不动，R 向右移。当窗口大小形成时，L 和 R 一起向右移，每次移动时，判断队首的值的数组下标是否在 [L,R] 中，如果不在则需要弹出队首的值，当前窗口的最大值即为队首的数。</p>
</blockquote>
<p>实际上，可以发现 <code>R=i</code>，<code>L=k-R</code>。由于队列中的值是从大到小排序的，所以每次窗口变动时，只需要判断队首的值是否还在窗口中就行了。</p>
<p>具体代码如下，代码很简洁，但时间效率就比较差了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 双向队列 保存当前窗口最大值的数组位置 保证队列中数组位置的数值按从大到小排序</span></span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">deque</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 判断当前队列中队首的值是否有效</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">deque</span>.empty() &amp;&amp; <span class="built_in">deque</span>.front() == i-k) </span><br><span class="line">                <span class="built_in">deque</span>.pop_front();</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// 保证从大到小 如果前面数小则需要依次弹出，直至满足要求</span></span><br><span class="line">            <span class="keyword">while</span> (!<span class="built_in">deque</span>.empty() &amp;&amp; nums[i] &gt; nums[<span class="built_in">deque</span>.back()]) </span><br><span class="line">                <span class="built_in">deque</span>.pop_back();</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">deque</span>.push_back(i);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 当窗口长度为k时 保存当前窗口中最大值</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k<span class="number">-1</span>) </span><br><span class="line">                res.push_back(nums[<span class="built_in">deque</span>.front()]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode每日一题2021.1.4</title>
    <url>/2021/01/04/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982021-1-4/</url>
    <content><![CDATA[<h1 id="2021-01-04"><a href="#2021-01-04" class="headerlink" title="2021.01.04"></a>2021.01.04</h1><p><a href="https://leetcode.com/problems/longest-increasing-subsequence/"><strong>300. Longest Increasing Subsequence [Medium]</strong></a> </p>
<blockquote>
<p>Given an integer array <code>nums</code>, return the length of the longest strictly increasing subsequence.</p>
<p>A <strong>subsequence</strong> is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, <code>[3,6,2,7]</code> is a subsequence of the array <code>[0,3,1,6,2,2,7]</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Input: nums = [<span class="number">10</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">101</span>,<span class="number">18</span>]</span><br><span class="line">Output: <span class="number">4</span></span><br><span class="line">Explanation: The longest increasing subsequence is [<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">101</span>], therefore the length is <span class="number">4.</span></span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<p>很经典的动态规划问题，明天要考算法设计与分析了，今天整道题练习一波，具体思路如下：</p>
<blockquote>
<p>dp[i]: 所有长度为i+1的递增子序列中, 最小的那个序列尾数.</p>
<p>由定义知dp数组必然是一个递增数组, 可以用 maxL 来表示最长递增子序列的长度. </p>
<p>对数组进行迭代, 依次判断每个数num将其插入dp数组相应的位置:</p>
<ol>
<li><p>num &gt; dp[maxL], 表示num比所有已知递增序列的尾数都大, 将num添加入dp数组尾部, 并将最长递增序列长度maxL加1</p>
</li>
<li><p>dp[i-1] &lt; num &lt;= dp[i], 只更新相应的dp[i]</p>
</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxL = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> *dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            <span class="comment">// 二分法查找, 也可以调用库函数如binary_search</span></span><br><span class="line">            <span class="keyword">int</span> lo = <span class="number">0</span>, hi = maxL;</span><br><span class="line">            <span class="keyword">while</span>(lo &lt; hi) &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = lo+(hi-lo)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(dp[mid] &lt; num)</span><br><span class="line">                    lo = mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    hi = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[lo] = num;</span><br><span class="line">            <span class="keyword">if</span>(lo == maxL)</span><br><span class="line">                maxL++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode每日一题2021.1.6</title>
    <url>/2021/01/06/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982021-1-6/</url>
    <content><![CDATA[<h1 id="2021-01-06"><a href="#2021-01-06" class="headerlink" title="2021.01.06"></a>2021.01.06</h1><p><a href="https://leetcode.com/problems/permutations/"><strong>46. Permutations [Medium]</strong></a> </p>
<blockquote>
<p>Given an array <code>nums</code> of distinct integers, return <em>all the possible permutations</em>. You can return the answer in <strong>any order</strong>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Input: nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">Output: [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Input: nums = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">Output: [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>]]</span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<p>从今天开始进行回溯算法专题训练，</p>
<blockquote>
<p><strong>回溯法</strong> 采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：找到一个可能存在的正确的答案；在尝试了所有可能的分步方法后宣告该问题没有答案。<br><strong>深度优先搜索 算法</strong>（英语：Depth-First-Search，DFS）是一种用于遍历或搜索树或图的算法。这个算法会 尽可能深 的搜索树的分支。当结点 v 的所在边都己被探寻过，搜索将 回溯 到发现结点 v 的那条边的起始结点。这一过程一直进行到已发现从源结点可达的所有结点为止。如果还存在未被发现的结点，则选择其中一个作为源结点并重复以上过程，整个进程反复进行直到所有结点都被访问为止。</p>
</blockquote>
<p>其本质还是DFS搜索，给出代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        dfs(res, re, used, nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; re, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; used, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(re.size() == nums.size()) &#123;</span><br><span class="line">            res.push_back(re);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i] != <span class="number">0</span>)  <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                re.push_back(nums[i]);</span><br><span class="line">                used[i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                dfs(res, re, used, nums);</span><br><span class="line"></span><br><span class="line">                re.pop_back();</span><br><span class="line">                used[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>算法系列之STL(一)</title>
    <url>/2020/09/09/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%E4%B9%8BSTL(%E4%B8%80)/</url>
    <content><![CDATA[<blockquote>
<p>STL来管理数据十分方便，省去了我们自己构建数据结构的时间。</p>
</blockquote>
<a id="more"></a>



<h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p><strong>标准模板库</strong>（<strong>Standard Template Library</strong>，缩写：<strong>STL</strong>），是一个C++软件库。其中包含4个组件，分别为算法、容器、函数、迭代器。</p>
<p><strong>模板</strong>是C++程序设计语言中的一个重要特征，而标准模板库正是基于此特征。标准模板库使得C++编程语言在有了同Java一样强大的类库的同时，保有了更大的可扩展器。</p>
<p>标准模板库包含了<strong>序列式容器</strong>、<strong>适配器容器</strong> 和 <strong>关联式容器</strong> 三种类型。</p>
<p>常见的STL容器有<strong>向量(vector)**、</strong>栈(stack)<strong>、</strong>队列(queue)**，在这里就不费笔墨多加介绍，本文主要介绍一些算法题中常用的STL容器。</p>
<h2 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h2><h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>容器deque和vector非常相似，属于序列式容器。都是采用动态数组来管理元素，提供随机存取，并且有着和vector一样的接口。不同的是，deque具有首尾两端进行快速插入、删除的能力。</p>
<blockquote>
<p>当需要向序列两端频繁的添加或删除元素时，应首选 deque 容器。</p>
</blockquote>
<h4 id="创建deque容器的几种方式"><a href="#创建deque容器的几种方式" class="headerlink" title="创建deque容器的几种方式"></a>创建deque容器的几种方式</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;<span class="comment">//创建一个没有任何元素的空的deque容器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//创建一个具有10个元素(默认都为0)的deque容器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(<span class="number">10</span>, <span class="number">5</span>)</span></span>;<span class="comment">//创建一个具有10个元素(值都为5)的deque容器</span></span><br></pre></td></tr></table></figure>
<h4 id="deque的主要函数"><a href="#deque的主要函数" class="headerlink" title="deque的主要函数"></a>deque的主要函数</h4><table>
<thead>
<tr>
<th align="center"><strong>函数成员</strong></th>
<th align="center"><strong>函数功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin()</td>
<td align="center">返回指向容器中第一个元素的迭代器。</td>
</tr>
<tr>
<td align="center">end()</td>
<td align="center">返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 begin() 结合使用。</td>
</tr>
<tr>
<td align="center">size()</td>
<td align="center">返回实际元素个数。</td>
</tr>
<tr>
<td align="center">empty()</td>
<td align="center">判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td>
</tr>
<tr>
<td align="center">push_back()</td>
<td align="center">在序列的尾部添加一个元素。</td>
</tr>
<tr>
<td align="center">push_front()</td>
<td align="center">在序列的头部添加一个元素。</td>
</tr>
<tr>
<td align="center">pop_back()</td>
<td align="center">移除容器尾部的元素。</td>
</tr>
<tr>
<td align="center">pop_front()</td>
<td align="center">移除容器头部的元素。</td>
</tr>
</tbody></table>
<hr>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>list容器的底层是以双向链表的形式实现的，各个元素的前后顺序是靠指针来维系的，每个元素都配备了 2 个指针，分别指向它的前一个元素和后一个元素。基于这样的存储结构它可以在序列已知的任何位置快速插入或删除元素，并且在 list 容器中移动元素，也比其它容器的效率高。但是list容器不可以通过位置直接访问元素，而是需要从容器中第一个元素或最后一个元素开始遍历容器，直到找到该位置。</p>
<blockquote>
<p>当需要对序列进行大量添加或删除元素的操作，而直接访问元素的需求却很少时，这种情况建议使用 list 容器存储序列。</p>
</blockquote>
<h4 id="创建list容器的几种方式"><a href="#创建list容器的几种方式" class="headerlink" title="创建list容器的几种方式"></a>创建list容器的几种方式</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; values;<span class="comment">//创建一个没有任何元素的空的list容器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">values</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//创建一个具有10个元素(默认都为0)的list容器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">values</span><span class="params">(<span class="number">10</span>, <span class="number">5</span>)</span></span>;<span class="comment">//创建一个具有10个元素(值都为5)的list容器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝其它类型的容器，创建 list 容器</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt;arr&#123; <span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;values(arr.begin()+<span class="number">2</span>, arr.end());<span class="comment">//拷贝arr容器中的&#123;13,14,15&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="list的主要函数"><a href="#list的主要函数" class="headerlink" title="list的主要函数"></a>list的主要函数</h4><table>
<thead>
<tr>
<th align="center"><strong>函数成员</strong></th>
<th align="center"><strong>函数功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin()</td>
<td align="center">返回指向容器中第一个元素的双向迭代器。</td>
</tr>
<tr>
<td align="center">end()</td>
<td align="center">返回指向容器中最后一个元素的双向迭代器。</td>
</tr>
<tr>
<td align="center">size()</td>
<td align="center">返回实际元素个数。</td>
</tr>
<tr>
<td align="center">empty()</td>
<td align="center">判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td>
</tr>
<tr>
<td align="center">push_back()</td>
<td align="center">在序列的尾部添加一个元素。</td>
</tr>
<tr>
<td align="center">push_front()</td>
<td align="center">在序列的头部添加一个元素。</td>
</tr>
<tr>
<td align="center">pop_back()</td>
<td align="center">移除容器尾部的元素。</td>
</tr>
<tr>
<td align="center">pop_front()</td>
<td align="center">移除容器头部的元素。</td>
</tr>
<tr>
<td align="center">insert()</td>
<td align="center">在容器中的指定位置插入元素。</td>
</tr>
<tr>
<td align="center">erase()</td>
<td align="center">删除容器中一个或某区域内的元素。</td>
</tr>
<tr>
<td align="center">sort()</td>
<td align="center">通过更改容器中元素的位置，将它们进行排序。</td>
</tr>
<tr>
<td align="center">reverse()</td>
<td align="center">反转容器中元素的顺序。</td>
</tr>
</tbody></table>
<h4 id="list容器元素的访问"><a href="#list容器元素的访问" class="headerlink" title="list容器元素的访问"></a>list容器元素的访问</h4><blockquote>
<p>只有运用迭代器，才能访问 list 容器中存储的各个元素。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">char</span>&gt; values&#123;<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;,&#x27;</span>,<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;J&#x27;</span>,<span class="string">&#x27;U&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">char</span>&gt;::iterator it = values.begin(); it != values.end(); ++it)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果为 Hello,NJU</span></span><br></pre></td></tr></table></figure>


<h2 id="适配器容器"><a href="#适配器容器" class="headerlink" title="适配器容器"></a>适配器容器</h2><p>容器适配器是一个封装了序列容器的类模板，它在一般序列容器的基础上提供了一些不同的功能。之所以称作适配器类，是因为它可以通过适配容器现有的接口来提供不同的功能。常见的容器适配器有三种，分别是<strong>stack、queue、priority_queue</strong>。其中<strong>栈(stack)**、</strong>队列(queue)**，是封装了 **deque<T> **容器的适配器类模板，是经常使用到的STL容器，在这里就不做过多介绍了。</p>
<p>本文主要介绍**优先级队列(priority_queue)**。</p>
<h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h3><blockquote>
<p>priority_queue<T>：是一个封装了 vector<T> 容器的适配器类模板，默认实现的是一个会对元素排序，从而保证最大元素总在队列最前面的队列。</p>
</blockquote>
<p>与queue类似的是，priority_queue 容器适配器模拟的也是队列这种存储结构，即使用此容器适配器存储元素只能“从一端进（称为队尾），从另一端出（称为队头）”，且每次只能访问 priority_queue 中位于队头的元素。</p>
<p>但是，priority_queue 容器适配器中元素的存和取，遵循的并不是 “First in,First out”（先入先出）原则，先进队列的元素并不一定先出队列，而是优先级最大的元素最先出队列。</p>
<p>priority_queue 容器适配器为了保证每次从队头移除的都是当前优先级最高的元素，每当有新元素进入，它都会根据既定的排序规则找到优先级最高的元素，并将其移动到队列的队头；同样，当 priority_queue 从队头移除出一个元素之后，它也会再找到当前优先级最高的元素，并将其移动到队头。</p>
<h4 id="priority-queue模板"><a href="#priority-queue模板" class="headerlink" title="priority_queue模板"></a>priority_queue模板</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, </span><br><span class="line">		  <span class="keyword">typename</span> Container=<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;, </span><br><span class="line">		  <span class="keyword">typename</span> Compare=<span class="built_in">std</span>::less&lt;T&gt;&gt; class <span class="built_in">priority_queue</span></span><br></pre></td></tr></table></figure>
<p>priority_queue 容器适配器模板类最多可以传入 3 个参数，它们各自的含义如下：</p>
<ul>
<li><p>typename T：指定存储元素的具体类型；</p>
</li>
<li><p>typename Container：指定 priority_queue 底层使用的基础容器，默认使用 vector 容器。</p>
<blockquote>
<p>作为 priority_queue 容器适配器的底层容器，其必须包含 empty()、size()、front()、push_back()、pop_back() 这几个成员函数，STL 序列式容器中只有 vector 和 deque 容器符合条件。</p>
</blockquote>
</li>
<li><p>typename Compare：指定容器中评定元素优先级所遵循的排序规则，默认使用<code>std::less&lt;T&gt;</code>按照元素值从大到小进行排序，还可以使用<code>std::greater&lt;T&gt;</code>按照元素值从小到大排序，但更多情况下是使用自定义的排序规则。</p>
</li>
</ul>
<h4 id="创建priority-queue的几种方式"><a href="#创建priority-queue的几种方式" class="headerlink" title="创建priority_queue的几种方式"></a>创建priority_queue的几种方式</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个空的 priority_queue 容器适配器,采用默认的vector容器和默认的排序方法 std::less&lt;T&gt;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt; values;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用普通数组或其它容器中指定范围内的数据，对 priority_queue 容器适配器进行初始化</span></span><br><span class="line"><span class="keyword">int</span> values[]&#123;<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt;copy_values(values,values+<span class="number">4</span>);<span class="comment">//&#123;4,2,3,1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//手动指定 priority_queue 使用的底层容器以及排序规则</span></span><br><span class="line"><span class="keyword">int</span> values[]&#123; <span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;, <span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt; &gt;copy_values(values, values+<span class="number">4</span>);<span class="comment">//&#123;1,3,2,4&#125;</span></span><br></pre></td></tr></table></figure>
<p>事实上，<code>std::less&lt;T&gt;</code> 和 <code>std::greater&lt;T&gt; </code>适用的场景是有限的，更多场景中我们会使用自定义的排序规则。</p>
<h4 id="priority-queue的主要函数"><a href="#priority-queue的主要函数" class="headerlink" title="priority_queue的主要函数"></a>priority_queue的主要函数</h4><table>
<thead>
<tr>
<th align="center"><strong>函数成员</strong></th>
<th align="center"><strong>函数功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">empty()</td>
<td align="center">如果 priority_queue 为空的话，返回 true；反之，返回 false。</td>
</tr>
<tr>
<td align="center">size()</td>
<td align="center">返回 priority_queue 中存储元素的个数。</td>
</tr>
<tr>
<td align="center">top()</td>
<td align="center">返回 priority_queue 中第一个元素的引用形式。</td>
</tr>
<tr>
<td align="center">push(const T&amp; obj)</td>
<td align="center">根据既定的排序规则，将元素 obj 的副本存储到 priority_queue 中适当的位置。</td>
</tr>
<tr>
<td align="center">push(T&amp;&amp; obj)</td>
<td align="center">根据既定的排序规则，将元素 obj 移动存储到 priority_queue 中适当的位置。</td>
</tr>
<tr>
<td align="center">pop()</td>
<td align="center">移除 priority_queue 容器适配器中第一个元素。</td>
</tr>
<tr>
<td align="center">swap(priority_queue<T>&amp; other)</td>
<td align="center">将两个 priority_queue 容器适配器中的元素进行互换，需要注意的是，进行互换的 2 个 priority_queue 容器适配器中存储的元素类型以及底层采用的基础容器类型，都必须相同。</td>
</tr>
</tbody></table>
<blockquote>
<p>和 queue 一样，priority_queue 也没有迭代器，因此访问元素的唯一方式是遍历容器，通过不断移除访问过的元素，去访问下一个元素。</p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://c.biancheng.net/stl/" title="STL教程：C++ STL快速入门">STL教程：C++ STL快速入门</a> , <strong>[ C语言中文网 ]</strong></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>算法系列之STL(三)</title>
    <url>/2020/09/10/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%E4%B9%8BSTL(%E4%B8%89)/</url>
    <content><![CDATA[<blockquote>
<p>STL提供了一些常见的算法，如排序和搜索等。这些算法与数据结构的实现进行了分离。</p>
</blockquote>
<a id="more"></a>



<h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>STL算法部分主要由头文件<code>&lt;algorithm&gt;</code>,<code>&lt;numeric&gt;</code>,<code>&lt;functional&gt;</code>组成。要使用 STL中的算法函数必须包含头文件<code>&lt;algorithm&gt;</code>，对于数值算法须包含<code>&lt;numeric&gt;</code>，<code>&lt;functional&gt;</code>中则定义了一些模板类，用来声明函数对象。</p>
<p> STL中算法大致分为四类：</p>
<ol>
<li>非可变序列算法：指不直接修改其所操作的容器内容的算法。</li>
<li>可变序列算法：指可以修改它们所操作的容器内容的算法。</li>
<li>排序算法：包括对序列进行排序和合并的算法、搜索算法以及有序序列上的集合操作。</li>
<li>数值算法：对容器内容进行数值计算。</li>
</ol>
<h2 id="排序函数"><a href="#排序函数" class="headerlink" title="排序函数"></a>排序函数</h2><table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">用法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">sort (first, last)</td>
<td align="center">对容器或普通数组中 [first, last) 范围内的元素进行排序，默认进行升序排序。</td>
</tr>
<tr>
<td align="center">stable_sort (first, last)</td>
<td align="center">和 sort() 函数功能相似，不同之处在于，对于 [first, last) 范围内值相同的元素，该函数不会改变它们的相对位置。</td>
</tr>
<tr>
<td align="center">partial_sort (first, middle, last)</td>
<td align="center">从 [first,last) 范围内，筛选出 middle-first 个最小的元素并排序存放在 [first，middle) 区间中。</td>
</tr>
<tr>
<td align="center">is_sorted (first, last)</td>
<td align="center">检测 [first, last) 范围内是否已经排好序，默认检测是否按升序排序。</td>
</tr>
<tr>
<td align="center">void nth_element (first, n_th, last)</td>
<td align="center">找到 [first, last) 范围内按照排序规则（默认按照升序排序）应该位于第 n_th 个位置处的元素，并将其放置到此位置。同时使该位置左侧的所有元素都比其存放的元素小，该位置右侧的所有元素都比其存放的元素大。</td>
</tr>
</tbody></table>
<p>对于表中罗列的这些函数，本文会选取一部分常用的函数进行介绍。</p>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3><p>C++ STL 标准库中的 sort() 函数，本质就是一个模板函数。该函数专门用来对容器或普通数组中指定范围内的元素进行排序，排序规则默认以元素值的大小做升序排序，除此之外我们也可以选择标准库提供的其它排序规则（比如<code>std::greater&lt;T&gt;</code>降序排序规则），也可以自定义排序规则。</p>
<blockquote>
<p>sort() 函数是基于快速排序实现的</p>
</blockquote>
<p>注意：</p>
<ol>
<li>容器支持的迭代器类型必须为随机访问迭代器。这意味着，sort() 只对 array、vector、deque 这 3 个容器提供支持。</li>
<li>如果对容器中指定区域的元素做默认升序排序，则元素类型必须支持<code>&lt;</code>小于运算符；同样，如果选用标准库提供的其它排序规则，元素类型也必须支持该规则底层实现所用的比较运算符；</li>
<li>sort() 函数在实现排序时，需要交换容器中元素的存储位置。这种情况下，如果容器中存储的是自定义的类对象，则该类的内部必须提供移动构造函数和移动赋值运算符。</li>
<li>另外还需要注意的一点是，对于指定区域内值相等的元素，sort() 函数无法保证它们的相对位置不发生改变。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对 [first, last) 区域内的元素做默认的升序排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span> <span class="params">(RandomAccessIterator first, RandomAccessIterator last)</span></span>;</span><br><span class="line"><span class="comment">//按照指定的 cmp 排序规则，对 [first, last) 区域内的元素进行排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span> <span class="params">(RandomAccessIterator first, RandomAccessIterator last, Compare cmp)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中，<code>first</code> 和 <code>last </code>都为随机访问迭代器，它们的组合<code>[first, last)</code>用来指定要排序的目标区域</p>
<p><code>cmp</code> 可以是 C++ STL 标准库提供的排序规则（比如 <code>std::greater&lt;T&gt;</code>），也可以是自定义的排序规则，如：</p>
<p>使用函数对象自定义排序规则；重载关系运算符实现自定义排序；或者直接定义一个具有 2 个参数并返回 bool 类型值的函数作为排序规则。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以普通函数的方式实现自定义排序规则</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mycmp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i &lt; j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以函数对象的方式实现自定义排序规则</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mycmp2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i &lt; j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="stable-sort"><a href="#stable-sort" class="headerlink" title="stable_sort()"></a>stable_sort()</h3><p><code>stable_sort()</code> 函数可以看作是 <code>sort()</code> 函数在功能方面的升级版。换句话说，<code>stable_sort()</code> 和 <code>sort()</code> 具有相同的使用场景，就连语法格式也是相同的，只不过<code>stable_sort()</code>在功能上除了可以实现排序，还可以保证不改变相等元素的相对位置。</p>
<hr>
<h3 id="partial-sort"><a href="#partial-sort" class="headerlink" title="partial_sort()"></a>partial_sort()</h3><p>partial_sort() 函数有 2 种用法，其语法格式分别为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按照默认的升序排序规则，对 [first, last) 范围的数据进行筛选并排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">partial_sort</span> <span class="params">(RandomAccessIterator first,RandomAccessIterator middle,RandomAccessIterator last)</span></span>;</span><br><span class="line"><span class="comment">//按照 cmp 排序规则，对 [first, last) 范围的数据进行筛选并排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">partial_sort</span> <span class="params">(RandomAccessIterator first,RandomAccessIterator middle,</span></span></span><br><span class="line"><span class="function"><span class="params">                   RandomAccessIterator last,Compare cmp)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中，<code>first</code>、<code>middle</code> 和 <code>last</code> 都是随机访问迭代器，<code>cmp</code> 参数用于自定义排序规则。</p>
<p><code>partial_sort()</code> 函数会以交换元素存储位置的方式实现部分排序的。具体来说，<code>partial_sort()</code> 会将 <code>[first, last)</code> 范围内最小（或最大）的 <code>middle-first </code>个元素移动到 <code>[first, middle)</code> 区域中，并对这部分元素做升序（或降序）排序。</p>
<p>代码演示如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mycmp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i &gt; j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector&#123; <span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以默认的升序排序作为排序规则,将 myvector 中最小的 4 个元素移动到开头位置并排好序</span></span><br><span class="line"><span class="built_in">std</span>::partial_sort(myvector.begin(), myvector.begin() + <span class="number">4</span>, myvector.end());<span class="comment">//1 2 3 4 5 6 9 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以指定的 mycmp 作为排序规则，将 myvector 中最大的 4 个元素移动到开头位置并排好序</span></span><br><span class="line"><span class="built_in">std</span>::partial_sort(myvector.begin(), myvector.begin() + <span class="number">4</span>, myvector.end(), mycmp());<span class="comment">//9 7 6 5 1 2 3 4</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="is-sorted"><a href="#is-sorted" class="headerlink" title="is_sorted()"></a>is_sorted()</h3><p>is_sorted() 函数有 2 种语法格式，分别是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断 [first, last) 区域内的数据是否符合 std::less&lt;T&gt; 排序规则，即是否为升序序列</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_sorted</span> <span class="params">(ForwardIterator first, ForwardIterator last)</span></span>;</span><br><span class="line"><span class="comment">//判断 [first, last) 区域内的数据是否符合 cmp 排序规则  </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_sorted</span> <span class="params">(ForwardIterator first, ForwardIterator last, Compare cmp)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中，<code>first</code> 和 <code>last</code> 都为正向迭代器（这意味着该函数适用于大部分容器），<code>[first, last) </code>用于指定要检测的序列；<code>cmp</code> 用于指定自定义的排序规则。</p>
<p>该函数会返回一个<code> bool</code> 类型值，即如果<code> [first, last)</code> 范围内的序列符合我们指定的排序规则，则返回 true；反之，函数返回 false。值得一提得是，如果 <code>[first, last)</code> 指定范围内只有 1 个元素，则该函数始终返回 true。</p>
<hr>
<h3 id="nth-element"><a href="#nth-element" class="headerlink" title="nth_element()"></a>nth_element()</h3><p>在有序序列中，我们可以称第 n 个元素为整个序列中“第 n 大”的元素。</p>
<p>简单的理解 nth_element() 函数的功能，当采用默认的升序排序规则（std::less<T>）时，该函数可以从某个序列中找到第 n 小的元素 K，并将 K 移动到序列中第 n 的位置处。不仅如此，整个序列经过 nth_element() 函数处理后，所有位于 K 之前的元素都比 K 小，所有位于 K 之后的元素都比 K 大。</p>
<p>nth_element() 函数有以下 2 种语法格式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//排序规则采用默认的升序排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nth_element</span> <span class="params">(RandomAccessIterator first,RandomAccessIterator nth,RandomAccessIterator last)</span></span>;</span><br><span class="line"><span class="comment">//排序规则为自定义的 cmp 排序规则</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nth_element</span> <span class="params">(RandomAccessIterator first,RandomAccessIterator nth,</span></span></span><br><span class="line"><span class="function"><span class="params">                  RandomAccessIterator last,Compare cmp)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中，各个参数的含义如下：</p>
<p>first 和 last：都是随机访问迭代器，[first, last) 用于指定该函数的作用范围（即要处理哪些数据）；</p>
<p>nth：也是随机访问迭代器，其功能是令函数查找“第 nth 大”的元素，并将其移动到 nth 指向的位置；</p>
<p>comp：用于自定义排序规则。</p>
<p>代码演示如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mycmp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i &gt; j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector&#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认的升序排序作为排序规则</span></span><br><span class="line">	<span class="built_in">std</span>::nth_element(myvector.begin(), myvector.begin()+<span class="number">2</span>, myvector.end());<span class="comment">//1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义的 mycmp 降序排序作为排序规则</span></span><br><span class="line">    <span class="built_in">std</span>::nth_element(myvector.begin(), myvector.begin() + <span class="number">3</span>, myvector.end(),mycmp);<span class="comment">//5 4 3 2 1</span></span><br></pre></td></tr></table></figure>


<h2 id="合并算法"><a href="#合并算法" class="headerlink" title="合并算法"></a>合并算法</h2><h3 id="merge"><a href="#merge" class="headerlink" title="merge()"></a>merge()</h3><p>merge() 函数用于将 2 个有序序列合并为 1 个有序序列，前提是这 2 个有序序列的排序规则相同（要么都是升序，要么都是降序）。并且最终借助该函数获得的新有序序列，其排序规则也和这 2 个有序序列相同。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以默认的升序排序作为排序规则</span></span><br><span class="line"><span class="function">OutputIterator <span class="title">merge</span> <span class="params">(InputIterator1 first1, InputIterator1 last1,</span></span></span><br><span class="line"><span class="function"><span class="params">                      InputIterator2 first2, InputIterator2 last2,</span></span></span><br><span class="line"><span class="function"><span class="params">                      OutputIterator result)</span></span>;</span><br><span class="line"><span class="comment">//以自定义的 comp 规则作为排序规则</span></span><br><span class="line"><span class="function">OutputIterator <span class="title">merge</span> <span class="params">(InputIterator1 first1, InputIterator1 last1,</span></span></span><br><span class="line"><span class="function"><span class="params">                      InputIterator2 first2, InputIterator2 last2,</span></span></span><br><span class="line"><span class="function"><span class="params">                      OutputIterator result, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure>
<p>first1、last1、first2 以及 last2 都为输入迭代器，[first1, last1) 和 [first2, last2) 各用来指定一个有序序列；result 为输出迭代器，用于为最终生成的新有序序列指定存储位置；comp 用于自定义排序规则。同时，该函数会返回一个输出迭代器，其指向的是新有序序列中最后一个元素之后的位置。</p>
<hr>
<h3 id="inplace-merge"><a href="#inplace-merge" class="headerlink" title="inplace_merge()"></a>inplace_merge()</h3><p>当 2 个有序序列存储在同一个数组或容器中时，如果想将它们合并为 1 个有序序列，除了使用 merge() 函数，更推荐使用 inplace_merge() 函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认采用升序的排序规则</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inplace_merge</span> <span class="params">(BidirectionalIterator first, BidirectionalIterator middle,</span></span></span><br><span class="line"><span class="function"><span class="params">                    BidirectionalIterator last)</span></span>;</span><br><span class="line"><span class="comment">//采用自定义的 comp 排序规则</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inplace_merge</span> <span class="params">(BidirectionalIterator first, BidirectionalIterator middle,</span></span></span><br><span class="line"><span class="function"><span class="params">                    BidirectionalIterator last, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中，first、middle 和 last 都为双向迭代器，[first, middle) 和 [middle, last) 各表示一个有序序列。</p>
<h2 id="查找函数"><a href="#查找函数" class="headerlink" title="查找函数"></a>查找函数</h2><h3 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h3><p>find() 函数用于在指定范围内查找和目标元素值相等的第一个元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">InputIterator <span class="title">find</span> <span class="params">(InputIterator first, InputIterator last, <span class="keyword">const</span> T&amp; val)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>first</code> 和 <code>last </code>为输入迭代器，<code>[first, last)</code> 用于指定该函数的查找范围；<code>val </code>为要查找的目标元素。</p>
<p>该函数会返回一个输入迭代器，当 find() 函数查找成功时，其指向的是在 <code>[first, last) </code>区域内查找到的第一个目标元素；如果查找失败，则该迭代器的指向和 <code>last</code> 相同。</p>
<hr>
<h3 id="find-end"><a href="#find-end" class="headerlink" title="find_end()"></a>find_end()</h3><p>ind_end() 函数定义在<code>&lt;algorithm&gt;</code>头文件中，常用于在序列 A 中查找序列 B 最后一次出现的位置。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找序列 [first1, last1) 中最后一个子序列 [first2, last2)</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">find_end</span> <span class="params">(ForwardIterator first1, ForwardIterator last1,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ForwardIterator first2, ForwardIterator last2)</span></span>;</span><br><span class="line"><span class="comment">//查找序列 [first2, last2) 中，和 [first2, last2) 序列满足 pred 规则的最后一个子序列</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">find_end</span> <span class="params">(ForwardIterator first1, ForwardIterator last1,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ForwardIterator first2, ForwardIterator last2,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BinaryPredicate pred)</span></span>;</span><br></pre></td></tr></table></figure>
<p>find_end() 函数会返回一个正向迭代器，当函数查找成功时，该迭代器指向查找到的子序列中的第一个元素；反之，如果查找失败，则该迭代器的指向和<code> last1</code> 迭代器相同。</p>
<hr>
<h3 id="find-first-of"><a href="#find-first-of" class="headerlink" title="find_first_of()"></a>find_first_of()</h3><p>find_first_of() 函数实现了在 A 序列中查找和 B 序列中任意元素相匹配的第一个元素。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以判断两者相等作为匹配规则</span></span><br><span class="line"><span class="function">InputIterator <span class="title">find_first_of</span> <span class="params">(InputIterator first1, InputIterator last1,</span></span></span><br><span class="line"><span class="function"><span class="params">                             ForwardIterator first2, ForwardIterator last2)</span></span>;</span><br><span class="line"><span class="comment">//以 pred 作为匹配规则</span></span><br><span class="line"><span class="function">InputIterator <span class="title">find_first_of</span> <span class="params">(InputIterator first1, InputIterator last1,</span></span></span><br><span class="line"><span class="function"><span class="params">                             ForwardIterator first2, ForwardIterator last2,</span></span></span><br><span class="line"><span class="function"><span class="params">                             BinaryPredicate pred)</span></span>;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="search"><a href="#search" class="headerlink" title="search()"></a>search()</h3><p>search() 函数定的功能恰好和 find_end() 函数相反，用于在序列 A 中查找序列 B 第一次出现的位置。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找 [first1, last1) 范围内第一个 [first2, last2) 子序列</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">search</span> <span class="params">(ForwardIterator first1, ForwardIterator last1,</span></span></span><br><span class="line"><span class="function"><span class="params">                        ForwardIterator first2, ForwardIterator last2)</span></span>;</span><br><span class="line"><span class="comment">//查找 [first1, last1) 范围内，和 [first2, last2) 序列满足 pred 规则的第一个子序列</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">search</span> <span class="params">(ForwardIterator first1, ForwardIterator last1,</span></span></span><br><span class="line"><span class="function"><span class="params">                        ForwardIterator first2, ForwardIterator last2,</span></span></span><br><span class="line"><span class="function"><span class="params">                        BinaryPredicate pred)</span></span>;</span><br></pre></td></tr></table></figure>


<h2 id="分组函数"><a href="#分组函数" class="headerlink" title="分组函数"></a>分组函数</h2><h3 id="partition"><a href="#partition" class="headerlink" title="partition()"></a>partition()</h3><p>partition 可直译为“分组”，partition() 函数可根据用户自定义的筛选规则，重新排列指定区域内存储的数据，使其分为 2 组，第一组为符合筛选条件的数据，另一组为不符合筛选条件的数据。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ForwardIterator <span class="title">partition</span> <span class="params">(ForwardIterator first,ForwardIterator last,</span></span></span><br><span class="line"><span class="function"><span class="params">                           UnaryPredicate pred)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中，<code>first</code> 和 <code>last</code> 都为正向迭代器，其组合 <code>[first, last)</code> 用于指定该函数的作用范围；<code>pred</code> 用于指定筛选规则。</p>
<p>partition() 函数还会返回一个正向迭代器，其指向的是两部分数据的分界位置，更确切地说，指向的是第二组数据中的第 1 个元素。</p>
<p>代码演示如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mycmp</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="keyword">return</span> (i % <span class="number">2</span>) == <span class="number">0</span>; &#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector&#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator bound;</span><br><span class="line"></span><br><span class="line">bound = <span class="built_in">std</span>::partition(myvector.begin(), myvector.end(), mycmp());</span><br><span class="line"><span class="comment">//输出结果为8 2 6 4 5 3 7 1 9, bound = 5</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="stable-partition"><a href="#stable-partition" class="headerlink" title="stable_partition()"></a>stable_partition()</h3><p>partition() 函数只负责对指定区域内的数据进行分组，并不保证各组中元素的相对位置不发生改变。而如果想在分组的同时保证不改变各组中元素的相对位置，可以使用 stable_partition() 函数。</p>
<p>换句话说，<code>stable_partition()</code> 和 <code>partition(()</code> 具有相同的使用场景，就连语法格式也是相同的，只不过<code>stable_partition()</code>在功能上除了可以实现排序，还可以保证不改变相等元素的相对位置。</p>
<h2 id="翻转函数"><a href="#翻转函数" class="headerlink" title="翻转函数"></a>翻转函数</h2><h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h3><p>reverse函数功能是逆序（或反转），多用于字符串、数组、容器。</p>
<p>reverse函数用于反转在<code>[first,last)</code>范围内的顺序（包括<code>first</code>指向的元素，不包括<code>last</code>指向的元素）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> str=<span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">reverse(str.begin(),str.end());<span class="comment">//str结果为dlrow olleh</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">reverse(v.begin(),v.end());<span class="comment">//容器v的值变为1,2,3,4,5</span></span><br></pre></td></tr></table></figure>


<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://c.biancheng.net/stl/" title="STL教程：C++ STL快速入门">STL教程：C++ STL快速入门</a> , <strong>[ C语言中文网 ]</strong></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>简单正则表达式入门</title>
    <url>/2020/07/01/%E7%AE%80%E5%8D%95%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<blockquote>
<p>正则表达式是一组由字母和符号组成的特殊文本，它可以用来从文本中找出满足你想要的格式的句子。</p>
</blockquote>
<a id="more"></a>



<h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p><strong>正则表达式</strong>（英语：Regular Expression，常简写为regex、regexp或RE），又称<strong>正规表示式、正规表示法、规则表达式、常规表示法</strong>，是计算机科学的一个概念。正规表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。在很多文本编辑器里，正规表达式通常被用来检索、替换那些符合某个模式的文本。</p>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><blockquote>
<p>正则表达式其实就是在执行搜索时的格式，它由一些字母和数字组合而成。</p>
</blockquote>
<h3 id="基础匹配"><a href="#基础匹配" class="headerlink" title="基础匹配"></a>基础匹配</h3><p>最基础的正则表达式就是一个字符串，例如：一个正则表达式 <code>the</code>，它表示一个规则：由字母<code>t</code>开始，接着是<code>h</code>，再接着是<code>e</code>。</p>
<pre>
"the" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>


<p>正则表达式是大小写敏感的，所以<code>The</code>不会匹配<code>the</code>。</p>
<h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><p>正则表达式主要依赖于元字符。 元字符不代表他们本身的字面意思，他们都有特殊的含义。一些元字符写在方括号中的时候有一些特殊的意思。</p>
<table>
<thead>
<tr>
<th align="center">元字符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">.</td>
<td align="center">句号匹配任意单个字符除了换行符。</td>
</tr>
<tr>
<td align="center">[ ]</td>
<td align="center">字符种类。匹配方括号内的任意字符。</td>
</tr>
<tr>
<td align="center">[^ ]</td>
<td align="center">否定的字符种类。匹配除了方括号里的任意字符</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">匹配&gt;=0个重复的在*号之前的字符。</td>
</tr>
<tr>
<td align="center">+</td>
<td align="center">匹配&gt;=1个重复的+号前的字符。</td>
</tr>
<tr>
<td align="center">?</td>
<td align="center">标记?之前的字符为可选.</td>
</tr>
<tr>
<td align="center">{n,m}</td>
<td align="center">匹配num个大括号之前的字符或字符集 (n &lt;= num &lt;= m).</td>
</tr>
<tr>
<td align="center">(xyz)</td>
<td align="center">字符集，匹配与 xyz 完全相等的字符串.</td>
</tr>
<tr>
<td align="center">|</td>
<td align="center">或运算符，匹配符号前或后的字符.</td>
</tr>
<tr>
<td align="center">\</td>
<td align="center">转义字符,用于匹配一些保留的字符 `[ ] ( ) { } . * + ? ^ $ \</td>
</tr>
<tr>
<td align="center">^</td>
<td align="center">从开始行开始匹配.</td>
</tr>
<tr>
<td align="center">$</td>
<td align="center">从末端开始匹配.</td>
</tr>
</tbody></table>
<h4 id="点运算符"><a href="#点运算符" class="headerlink" title="点运算符 ."></a>点运算符 <code>.</code></h4><p><code>.</code>是元字符中最简单的例子。<br><code>.</code>匹配任意单个字符，但不匹配换行符。<br>例如，表达式<code>.ar</code>匹配一个任意字符后面跟着是<code>a</code>和<code>r</code>的字符串。</p>
<pre>
".ar" => The <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<h4 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h4><h5 id="字符集-1"><a href="#字符集-1" class="headerlink" title="字符集"></a>字符集</h5><p>字符集也叫做字符类。<br>方括号用来指定一个字符集。<br>在方括号中使用连字符来指定字符集的范围。<br>在方括号中的字符集不关心顺序。<br>例如，表达式<code>[Tt]he</code> 匹配 <code>the</code> 和 <code>The</code>。</p>
<pre>
"[Tt]he" => <a href="#learn-regex"><strong>The</strong></a> car parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>

<p>方括号的句号就表示句号。<br>表达式 <code>ar[.]</code> 匹配 <code>ar.</code>字符串</p>
<pre>
"ar[.]" => A garage is a good place to park a c<a href="#learn-regex"><strong>ar.</strong></a>
</pre>

<h5 id="否定字符集"><a href="#否定字符集" class="headerlink" title="否定字符集"></a>否定字符集</h5><p>一般来说 <code>^</code> 表示一个字符串的开头，但它用在一个方括号的开头的时候，它表示这个字符集是否定的。<br>例如，表达式<code>[^c]ar</code> 匹配一个后面跟着<code>ar</code>的除了<code>c</code>的任意字符。</p>
<pre>
"[^c]ar" => The car <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<h4 id="重复次数"><a href="#重复次数" class="headerlink" title="重复次数"></a>重复次数</h4><p>后面跟着元字符 <code>+</code>，<code>*</code> or <code>?</code> 的，用来指定匹配子模式的次数。<br>这些元字符在不同的情况下有着不同的意思。</p>
<h5 id="号"><a href="#号" class="headerlink" title="* 号"></a><code>*</code> 号</h5><p><code>*</code>号匹配 在<code>*</code>之前的字符出现<code>大于等于0</code>次。<br>例如，表达式 <code>a*</code> 匹配0或更多个以a开头的字符。表达式<code>[a-z]*</code> 匹配一个行中所有以小写字母开头的字符串。</p>
<pre>
"[a-z]*" => T<a href="#learn-regex"><strong>he</strong></a> <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>parked</strong></a> <a href="#learn-regex"><strong>in</strong></a> <a href="#learn-regex"><strong>the</strong></a> <a href="#learn-regex"><strong>garage</strong></a> #21.
</pre>

<p><code>*</code>字符和<code>.</code>字符搭配可以匹配所有的字符<code>.*</code>。<br><code>*</code>和表示匹配空格的符号<code>\s</code>连起来用，如表达式<code>\s*cat\s*</code>匹配0或更多个空格开头和0或更多个空格结尾的cat字符串。</p>
<pre>
"\s*cat\s*" => The fat<a href="#learn-regex"><strong> cat </strong></a>sat on the con<a href="#learn-regex"><strong>cat</strong></a>enation.
</pre>

<h5 id="号-1"><a href="#号-1" class="headerlink" title="+ 号"></a><code>+</code> 号</h5><p><code>+</code>号匹配<code>+</code>号之前的字符出现 &gt;=1 次。<br>例如表达式<code>c.+t</code> 匹配以首字母<code>c</code>开头以<code>t</code>结尾，中间跟着至少一个字符的字符串。</p>
<pre>
"c.+t" => The fat <a href="#learn-regex"><strong>cat sat on the mat</strong></a>.
</pre>

<h5 id="号-2"><a href="#号-2" class="headerlink" title="? 号"></a><code>?</code> 号</h5><p>在正则表达式中元字符 <code>?</code> 标记在符号前面的字符为可选，即出现 0 或 1 次。<br>例如，表达式 <code>[T]?he</code> 匹配字符串 <code>he</code> 和 <code>The</code>。</p>
<pre>
"[T]he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.
</pre>

<pre>
"[T]?he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in t<a href="#learn-regex"><strong>he</strong></a> garage.
</pre>

<h4 id="号-3"><a href="#号-3" class="headerlink" title="{} 号"></a><code>&#123;&#125;</code> 号</h4><p>在正则表达式中 <code>&#123;&#125;</code> 是一个量词，常用来限定一个或一组字符可以重复出现的次数。<br>例如， 表达式 <code>[0-9]&#123;2,3&#125;</code> 匹配最少 2 位最多 3 位 0~9 的数字。</p>
<pre>
"[0-9]{2,3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.
</pre>

<p>我们可以省略第二个参数。<br>例如，<code>[0-9]&#123;2,&#125;</code> 匹配至少两位 0~9 的数字。</p>
<pre>
"[0-9]{2,}" => The number was 9.<a href="#learn-regex"><strong>9997</strong></a> but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.
</pre>

<p>如果逗号也省略掉则表示重复固定的次数。<br>例如，<code>[0-9]&#123;3&#125;</code> 匹配3位数字</p>
<pre>
"[0-9]{3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to 10.0.
</pre>

<h4 id="特征标群"><a href="#特征标群" class="headerlink" title="(...) 特征标群"></a><code>(...)</code> 特征标群</h4><p>特征标群是一组写在 <code>(...)</code> 中的子模式。<code>(...)</code> 中包含的内容将会被看成一个整体，和数学中小括号（ ）的作用相同。例如, 表达式 <code>(ab)*</code> 匹配连续出现 0 或更多个 <code>ab</code>。如果没有使用 <code>(...)</code> ，那么表达式 <code>ab*</code> 将匹配连续出现 0 或更多个 <code>b</code> 。再比如之前说的 <code>&#123;&#125;</code> 是用来表示前面一个字符出现指定次数。但如果在 <code>&#123;&#125;</code> 前加上特征标群 <code>(...)</code> 则表示整个标群内的字符重复 N 次。</p>
<p>我们还可以在 <code>()</code> 中用或字符 <code>|</code> 表示或。例如，<code>(c|g|p)ar</code> 匹配 <code>car</code> 或 <code>gar</code> 或 <code>par</code>.</p>
<pre>
"(c|g|p)ar" => The <a href="#learn-regex"><strong>car</strong></a> is <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<h4 id="或运算符"><a href="#或运算符" class="headerlink" title="| 或运算符"></a><code>|</code> 或运算符</h4><p>或运算符就表示或，用作判断条件。</p>
<p>例如 <code>(T|t)he|car</code> 匹配 <code>(T|t)he</code> 或 <code>car</code>。</p>
<pre>
"(T|t)he|car" => <a href="#learn-regex"><strong>The</strong></a> <a href="#learn-regex"><strong>car</strong></a> is parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>

<h4 id="转码特殊字符"><a href="#转码特殊字符" class="headerlink" title="转码特殊字符"></a>转码特殊字符</h4><p>反斜线 <code>\</code> 在表达式中用于转码紧跟其后的字符。用于指定 <code>&#123; &#125; [ ] / \ + * . $ ^ | ?</code> 这些特殊字符。如果想要匹配这些特殊字符则要在其前面加上反斜线 <code>\</code>。</p>
<p>例如 <code>.</code> 是用来匹配除换行符外的所有字符的。如果想要匹配句子中的 <code>.</code> 则要写成 <code>\.</code> 以下这个例子 <code>\.?</code>是选择性匹配<code>.</code></p>
<pre>
"(f|c|m)at\.?" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> sat on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>

<h4 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h4><p>在正则表达式中，想要匹配指定开头或结尾的字符串就要使用到锚点。<code>^</code> 指定开头，<code>$</code> 指定结尾。</p>
<h5 id="号-4"><a href="#号-4" class="headerlink" title="^ 号"></a><code>^</code> 号</h5><p><code>^</code> 用来检查匹配的字符串是否在所匹配字符串的开头。</p>
<p>例如，在 <code>abc</code> 中使用表达式 <code>^a</code> 会得到结果 <code>a</code>。但如果使用 <code>^b</code> 将匹配不到任何结果。因为在字符串 <code>abc</code> 中并不是以 <code>b</code> 开头。</p>
<p>例如，<code>^(T|t)he</code> 匹配以 <code>The</code> 或 <code>the</code> 开头的字符串。</p>
<pre>
"(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>

<pre>
"^(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.
</pre>

<h5 id="号-5"><a href="#号-5" class="headerlink" title="$ 号"></a><code>$</code> 号</h5><p>同理于 <code>^</code> 号，<code>$</code> 号用来匹配字符是否是最后一个。</p>
<p>例如，<code>(at\.)$</code> 匹配以 <code>at.</code> 结尾的字符串。</p>
<pre>
"(at\.)" => The fat c<a href="#learn-regex"><strong>at.</strong></a> s<a href="#learn-regex"><strong>at.</strong></a> on the m<a href="#learn-regex"><strong>at.</strong></a>
</pre>

<pre>
"(at\.)$" => The fat cat. sat. on the m<a href="#learn-regex"><strong>at.</strong></a>
</pre>



<h3 id="简写字符集"><a href="#简写字符集" class="headerlink" title="简写字符集"></a>简写字符集</h3><p>正则表达式提供一些常用的字符集简写。如下:</p>
<table>
<thead>
<tr>
<th align="center">简写</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">.</td>
<td>除换行符外的所有字符</td>
</tr>
<tr>
<td align="center">\w</td>
<td>匹配所有字母数字，等同于 <code>[a-zA-Z0-9_]</code></td>
</tr>
<tr>
<td align="center">\W</td>
<td>匹配所有非字母数字，即符号，等同于： <code>[^\w]</code></td>
</tr>
<tr>
<td align="center">\d</td>
<td>匹配数字： <code>[0-9]</code></td>
</tr>
<tr>
<td align="center">\D</td>
<td>匹配非数字： <code>[^\d]</code></td>
</tr>
<tr>
<td align="center">\s</td>
<td>匹配所有空格字符，等同于： <code>[\t\n\f\r\p&#123;Z&#125;]</code></td>
</tr>
<tr>
<td align="center">\S</td>
<td>匹配所有非空格字符： <code>[^\s]</code></td>
</tr>
<tr>
<td align="center">\f</td>
<td>匹配一个换页符</td>
</tr>
<tr>
<td align="center">\n</td>
<td>匹配一个换行符</td>
</tr>
<tr>
<td align="center">\r</td>
<td>匹配一个回车符</td>
</tr>
<tr>
<td align="center">\t</td>
<td>匹配一个制表符</td>
</tr>
<tr>
<td align="center">\v</td>
<td>匹配一个垂直制表符</td>
</tr>
<tr>
<td align="center">\p</td>
<td>匹配 CR/LF（等同于 <code>\r\n</code>），用来匹配 DOS 行终止符</td>
</tr>
</tbody></table>
<h3 id="零宽度断言（前后预查）"><a href="#零宽度断言（前后预查）" class="headerlink" title="零宽度断言（前后预查）"></a>零宽度断言（前后预查）</h3><p>先行断言和后发断言都属于<strong>非捕获簇</strong>（不捕获文本 ，也不针对组合计进行计数）。<br>先行断言用于判断所匹配的格式是否在另一个确定的格式之前，匹配结果不包含该确定格式（仅作为约束）。</p>
<p>例如，我们想要获得所有跟在 <code>$</code> 符号后的数字，我们可以使用正后发断言 <code>(?&lt;=\$)[0-9\.]*</code>。<br>这个表达式匹配 <code>$</code> 开头，之后跟着 <code>0,1,2,3,4,5,6,7,8,9,.</code> 这些字符可以出现大于等于 0 次。</p>
<p>零宽度断言如下：</p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">?=</td>
<td>正先行断言-存在</td>
</tr>
<tr>
<td align="center">?!</td>
<td>负先行断言-排除</td>
</tr>
<tr>
<td align="center">?&lt;=</td>
<td>正后发断言-存在</td>
</tr>
<tr>
<td align="center">?&lt;!</td>
<td>负后发断言-排除</td>
</tr>
</tbody></table>
<h4 id="正先行断言"><a href="#正先行断言" class="headerlink" title="?=... 正先行断言"></a><code>?=...</code> 正先行断言</h4><p><code>?=...</code> 正先行断言，表示第一部分表达式之后必须跟着 <code>?=...</code>定义的表达式。</p>
<p>返回结果只包含满足匹配条件的第一部分表达式。<br>定义一个正先行断言要使用 <code>()</code>。在括号内部使用一个问号和等号： <code>(?=...)</code>。</p>
<p>正先行断言的内容写在括号中的等号后面。<br>例如，表达式 <code>(T|t)he(?=\sfat)</code> 匹配 <code>The</code> 和 <code>the</code>，在括号中我们又定义了正先行断言 <code>(?=\sfat)</code> ，即 <code>The</code> 和 <code>the</code> 后面紧跟着 <code>(空格)fat</code>。</p>
<pre>
"(T|t)he(?=\sfat)" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>

<h4 id="负先行断言"><a href="#负先行断言" class="headerlink" title="?!... 负先行断言"></a><code>?!...</code> 负先行断言</h4><p>负先行断言 <code>?!</code> 用于筛选所有匹配结果，筛选条件为 其后不跟随着断言中定义的格式。<br><code>正先行断言</code>  定义和 <code>负先行断言</code> 一样，区别就是 <code>=</code> 替换成 <code>!</code> 也就是 <code>(?!...)</code>。</p>
<p>表达式 <code>(T|t)he(?!\sfat)</code> 匹配 <code>The</code> 和 <code>the</code>，且其后不跟着 <code>(空格)fat</code>。</p>
<pre>
"(T|t)he(?!\sfat)" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>

<h4 id="lt-正后发断言"><a href="#lt-正后发断言" class="headerlink" title="?&lt;= ... 正后发断言"></a><code>?&lt;= ...</code> 正后发断言</h4><p>正后发断言 记作<code>(?&lt;=...)</code> 用于筛选所有匹配结果，筛选条件为 其前跟随着断言中定义的格式。<br>例如，表达式 <code>(?&lt;=(T|t)he\s)(fat|mat)</code> 匹配 <code>fat</code> 和 <code>mat</code>，且其前跟着 <code>The</code> 或 <code>the</code>。</p>
<pre>
"(?<=(T|t)he\s)(fat|mat)" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the <a href="#learn-regex"><strong>mat</strong></a>.
</pre>

<h4 id="lt-负后发断言"><a href="#lt-负后发断言" class="headerlink" title="?&lt;!... 负后发断言"></a><code>?&lt;!...</code> 负后发断言</h4><p>负后发断言 记作 <code>(?&lt;!...)</code> 用于筛选所有匹配结果，筛选条件为 其前不跟随着断言中定义的格式。<br>例如，表达式 <code>(?&lt;!(T|t)he\s)(cat)</code> 匹配 <code>cat</code>，且其前不跟着 <code>The</code> 或 <code>the</code>。</p>
<pre>
"(?&lt;!(T|t)he\s)(cat)" => The cat sat on <a href="#learn-regex"><strong>cat</strong></a>.
</pre>



<h3 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h3><p>标志也叫模式修正符，因为它可以用来修改表达式的搜索结果。<br>这些标志可以任意的组合使用，它也是整个正则表达式的一部分。</p>
<table>
<thead>
<tr>
<th align="center">标志</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">i</td>
<td>忽略大小写。</td>
</tr>
<tr>
<td align="center">g</td>
<td>全局搜索。</td>
</tr>
<tr>
<td align="center">m</td>
<td>多行修饰符：锚点元字符 <code>^</code> <code>$</code> 工作范围在每行的起始。</td>
</tr>
</tbody></table>
<h4 id="忽略大小写-Case-Insensitive"><a href="#忽略大小写-Case-Insensitive" class="headerlink" title="忽略大小写 (Case Insensitive)"></a>忽略大小写 (Case Insensitive)</h4><p>修饰语 <code>i</code> 用于忽略大小写。<br>例如，表达式 <code>/The/gi</code> 表示在全局搜索 <code>The</code>，在后面的 <code>i</code> 将其条件修改为忽略大小写，则变成搜索 <code>the</code> 和 <code>The</code>，<code>g</code> 表示全局搜索。</p>
<pre>
"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>

<pre>
"/The/gi" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>

<h4 id="全局搜索-Global-search"><a href="#全局搜索-Global-search" class="headerlink" title="全局搜索 (Global search)"></a>全局搜索 (Global search)</h4><p>修饰符 <code>g</code> 常用于执行一个全局搜索匹配，即（不仅仅返回第一个匹配的，而是返回全部）。<br>例如，表达式 <code>/.(at)/g</code> 表示搜索 任意字符（除了换行）+ <code>at</code>，并返回全部结果。</p>
<pre>
"/.(at)/" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the mat.
</pre>

<pre>
"/.(at)/g" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> <a href="#learn-regex"><strong>sat</strong></a> on the <a href="#learn-regex"><strong>mat</strong></a>.
</pre>

<h4 id="多行修饰符-Multiline"><a href="#多行修饰符-Multiline" class="headerlink" title="多行修饰符 (Multiline)"></a>多行修饰符 (Multiline)</h4><p>多行修饰符 <code>m</code> 常用于执行一个多行匹配。</p>
<p>像之前介绍的 <code>(^,$)</code> 用于检查格式是否是在待检测字符串的开头或结尾。但我们如果想要它在每行的开头和结尾生效，我们需要用到多行修饰符 <code>m</code>。</p>
<p>例如，表达式 <code>/at(.)?$/gm</code> 表示小写字符 <code>a</code> 后跟小写字符 <code>t</code> ，末尾可选除换行符外任意字符。根据 <code>m</code> 修饰符，现在表达式匹配每行的结尾。</p>
<pre>
"/.at(.)?$/" => The fat
                cat sat
                on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>

<pre>
"/.at(.)?$/gm" => The <a href="#learn-regex"><strong>fat</strong></a>
                  cat <a href="#learn-regex"><strong>sat</strong></a>
                  on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>



<h3 id="贪婪匹配与惰性匹配-Greedy-vs-lazy-matching"><a href="#贪婪匹配与惰性匹配-Greedy-vs-lazy-matching" class="headerlink" title="贪婪匹配与惰性匹配 (Greedy vs lazy matching)"></a>贪婪匹配与惰性匹配 (Greedy vs lazy matching)</h3><p>正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。我们可以使用 <code>?</code> 将贪婪匹配模式转化为惰性匹配模式。</p>
<pre>
"/(.*at)/" => <a href="#learn-regex"><strong>The fat cat sat on the mat</strong></a>. </pre>

<pre>
"/(.*?at)/" => <a href="#learn-regex"><strong>The fat</strong></a> cat sat on the mat. </pre>



<h2 id="正则表达式在C-中的应用"><a href="#正则表达式在C-中的应用" class="headerlink" title="正则表达式在C++中的应用"></a>正则表达式在C++中的应用</h2><blockquote>
<p>std::regex是C++用来表示「正则表达式」（regular expression）的库</p>
</blockquote>
<p>在这里具体讲解，<strong>匹配、搜索、分词</strong>和<strong>替换</strong>四种操作</p>
<h3 id="匹配（March）"><a href="#匹配（March）" class="headerlink" title="匹配（March）"></a>匹配（March）</h3><p>字符串处理常用的一个操作是「匹配」，即字符串和规则恰好对应，而用于匹配的函数为std::regex_match()。</p>
<p>直接将待匹配字符串和模式字符串传入到regex_match中，返回一个bool量来指明待匹配的字符串是否满足模式字符串的规则。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">regex e;</span><br><span class="line"><span class="keyword">bool</span> match = regex_match(str, e);		<span class="comment">// 匹配整个字符串str</span></span><br></pre></td></tr></table></figure>
<h3 id="搜索（Search）"><a href="#搜索（Search）" class="headerlink" title="搜索（Search）"></a>搜索（Search）</h3><p>「搜索」与「匹配」非常相像，其对应的函数为std::regex_search，也是个函数模板，用法和regex_match一样，不同之处在于「搜索」只要字符串中有目标出现就会返回，而非完全「匹配」。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">regex e;</span><br><span class="line"><span class="keyword">bool</span> match = regex_search(str, e);		<span class="comment">// 查找字符串str中匹配e规则的子字符串</span></span><br></pre></td></tr></table></figure>
<h3 id="分词（Tokenize）"><a href="#分词（Tokenize）" class="headerlink" title="分词（Tokenize）"></a>分词（Tokenize）</h3><p>还有一种操作叫做「切割」，例如有一组数据保存着许多邮箱账号，并以逗号分隔，那就可以指定以逗号为分割符来切割这些内容，从而得到每个账号。</p>
<p>而在C++的正则中，把这种操作称为Tokenize，用模板类regex_token_iterator&lt;&gt;提供分词迭代器，依旧通过例子来看：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">mail</span><span class="params">(<span class="string">&quot;123@qq.vip.com,456@gmail.com,789@163.com,abcd@my.com&quot;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::regex <span class="title">reg</span><span class="params">(<span class="string">&quot;,&quot;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::sregex_token_iterator <span class="title">pos</span><span class="params">(mail.begin(), mail.end(), reg, <span class="number">-1</span>)</span></span>;</span><br><span class="line"><span class="keyword">decltype</span>(pos) end;</span><br><span class="line"><span class="keyword">for</span> (; pos != end; ++pos)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; pos-&gt;str() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就能通过逗号分割得到所有的邮箱。</p>
<h3 id="替换（Replace）"><a href="#替换（Replace）" class="headerlink" title="替换（Replace）"></a>替换（Replace）</h3><p>最后一种操作称为「替换」，即将正则表达式内容替换为指定内容，regex库用模板函数std::regex_replace提供「替换」操作。</p>
<p>例如，通过替换操作，删除字符串**”he…ll..o, worl..d!”<strong>中误敲的</strong>“.”**</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> data[] = <span class="string">&quot;he...ll..o, worl..d!&quot;</span>; </span><br><span class="line"><span class="function"><span class="built_in">std</span>::regex <span class="title">reg</span><span class="params">(<span class="string">&quot;\\.&quot;</span>)</span></span>; </span><br><span class="line"><span class="comment">// output: hello, world! </span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::regex_replace(data, reg, <span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>


<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/ziishaned/learn-regex" title="learn-regex">learn-regex</a> , <strong>[ github ]</strong></p>
<p><a href="https://www.cnblogs.com/coolcpp/p/cpp-regex.html" title="C++正则表达式">C++正则表达式</a> , <strong>[ cnblogs ]</strong></p>
]]></content>
      <categories>
        <category>入门知识</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>算法系列之STL(二)</title>
    <url>/2020/09/10/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%E4%B9%8BSTL(%E4%BA%8C)/</url>
    <content><![CDATA[<blockquote>
<p>能用STL算法，绝不自己实现！</p>
</blockquote>
<a id="more"></a>



<h2 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h2><p>关联式容器存储的是<strong>“键值对”</strong>形式的数据，例如&lt;”张三”, “20”&gt;就是一个键值对，其中第一个元素作为<strong>键(key)**，第二个元素作为</strong>值(value)**。</p>
<p>考虑到<strong>“键值对”</strong>并不是普通类型数据，C++ STL标准库提供了 <code>pair </code>类模板，其专门用来将 2 个普通元素 <code>first</code> 和 <code>second</code>（可以是 C++ 基本数据类型、结构体、类自定的类型）创建成一个新元素<code>&lt;first, second&gt;</code>。通过其构成的元素格式不难看出，使用 <code>pair</code> 类模板来创建“键值对”形式的元素，再合适不过。</p>
<hr>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>作为关联式容器的一种，map 容器存储的都是用<code>pair</code>类模板创建的键值对。与此同时，在使用 map 容器存储多个键值对时，该容器会自动根据各键值对的键的大小，按照既定的规则进行排序。默认情况下，map 容器选用<code>std::less&lt;T&gt;</code>排序规则（其中 T 表示键的数据类型），其会根据键的大小对所有键值对做升序排序。</p>
<blockquote>
<p>通常情况下，map 容器中存储的各个键值对都选用 string 字符串作为键的类型。与此同时，使用 map 容器存储的各个键值对，键的值既不能重复也不能被修改。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">Key</span>,                                     // 指定键（<span class="title">key</span>）的类型</span></span><br><span class="line"><span class="class">           <span class="keyword">class</span> <span class="title">T</span>,                                       // 指定值（<span class="title">value</span>）的类型</span></span><br><span class="line"><span class="class">           <span class="keyword">class</span> <span class="title">Compare</span> =</span> less&lt;Key&gt;,                     <span class="comment">// 指定排序规则</span></span><br><span class="line">           <span class="class"><span class="keyword">class</span> <span class="title">Alloc</span> =</span> allocator&lt;<span class="built_in">pair</span>&lt;<span class="keyword">const</span> Key,T&gt; &gt;    <span class="comment">// 指定分配器对象的类型</span></span><br><span class="line">           &gt; <span class="class"><span class="keyword">class</span> <span class="title">map</span>;</span></span><br></pre></td></tr></table></figure>
<h4 id="创建map容器的几种方式"><a href="#创建map容器的几种方式" class="headerlink" title="创建map容器的几种方式"></a>创建map容器的几种方式</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt;myMap;<span class="comment">//创建一个空的map容器</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt;myMap&#123;&#123;<span class="string">&quot;张三&quot;</span>, <span class="number">10</span>&#125;,&#123;<span class="string">&quot;李四&quot;</span>, <span class="number">20</span>&#125;&#125;;<span class="comment">//创建map容器的同时，对其初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//map类模板还支持取已建map容器中指定区域内的键值对，创建并初始化新的map容器</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt;myMap&#123;&#123;<span class="string">&quot;张三&quot;</span>, <span class="number">10</span>&#125;,&#123;<span class="string">&quot;李四&quot;</span>, <span class="number">20</span>&#125;&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt;newMap(++myMap.begin(), myMap.end());</span><br><span class="line"><span class="comment">//这里实现了在创建 newMap 容器的同时，将其初始化为包含一个 &#123;&quot;STL教程&quot;,20&#125; 键值对的容器</span></span><br></pre></td></tr></table></figure>
<h4 id="map的主要函数"><a href="#map的主要函数" class="headerlink" title="map的主要函数"></a>map的主要函数</h4><table>
<thead>
<tr>
<th align="center"><strong>函数成员</strong></th>
<th align="center"><strong>函数功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin()</td>
<td align="center">返回指向容器中第一个(已排好序的第一个)键值对的双向迭代器。</td>
</tr>
<tr>
<td align="center">end()</td>
<td align="center">返回指向容器最后一个元素（已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。</td>
</tr>
<tr>
<td align="center">find(key)</td>
<td align="center">在 map 容器中查找键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器;反之，则返回和 end() 方法一样的迭代器。</td>
</tr>
<tr>
<td align="center">empty()</td>
<td align="center">若容器为空，则返回 true；否则 false。</td>
</tr>
<tr>
<td align="center">size()</td>
<td align="center">返回当前 map 容器中存有键值对的个数。</td>
</tr>
<tr>
<td align="center">insert()</td>
<td align="center">向 map 容器中插入键值对。</td>
</tr>
<tr>
<td align="center">erase()</td>
<td align="center">删除 map 容器指定位置、指定键（key）值或者指定区域内的键值对。</td>
</tr>
<tr>
<td align="center">emplace()</td>
<td align="center">在当前 map 容器中的指定位置处构造新键值对。其效果和插入键值对一样，但效率更高。</td>
</tr>
<tr>
<td align="center">count(key)</td>
<td align="center">在当前 map 容器中，查找键为 key 的键值对的个数并返回。注意，由于 map 容器中各键值对的键的值是唯一的，因此该函数的返回值最大为 1。</td>
</tr>
<tr>
<td align="center">operator[]</td>
<td align="center">map容器重载了 [] 运算符，只要知道 map 容器中某个键值对的键的值，就可以向获取数组中元素那样，通过键直接获取对应的值。</td>
</tr>
<tr>
<td align="center">at(key)</td>
<td align="center">找到 map 容器中 key 键对应的值，如果找不到，该函数会引发 out_of_range 异常。</td>
</tr>
</tbody></table>
<h4 id="map容器获取键对应值的几种方法"><a href="#map容器获取键对应值的几种方法" class="headerlink" title="map容器获取键对应值的几种方法"></a>map容器获取键对应值的几种方法</h4><blockquote>
<p>注意，使用 map 容器存储的各个键值对，其键的值都是唯一的，因此指定键对应的值最多有 1 个。</p>
</blockquote>
<ol>
<li><p>map 类模板中对<code>[ ]</code>运算符进行了重载，这意味着，类似于借助数组下标可以直接访问数组中元素</p>
<p>需要注意的是当 map 容器中确实存有包含该指定键的键值对，借助重载的<code>[ ]</code> 运算符才能成功获取该键对应的值；反之，若当前 map 容器中没有包含该指定键的键值对，则此时使用 <code>[ ]</code> 运算符将不再是访问容器中的元素，而变成了向该 map 容器中增添一个键值对。</p>
</li>
<li><p>还可以使用 at() 成员方法。</p>
<p>和第一种方法相比，at() 成员方法也需要根据指定的键，才能从容器中找到该键对应的值；不同之处在于，如果在当前容器中查找失败，该方法不会向容器中添加新的键值对，而是直接抛出 out_of_range 异常。</p>
</li>
</ol>
<h4 id="map容器插入数据的几种方式"><a href="#map容器插入数据的几种方式" class="headerlink" title="map容器插入数据的几种方式"></a>map容器插入数据的几种方式</h4><ol>
<li><p>利用<code>[ ]</code>添加新的键值对，或修改<code>map</code>容器已存储键值对中，指定键对应的值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; mymap&#123;&#123;<span class="string">&quot;张三&quot;</span>, <span class="number">10</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向map容器添加新键值对</span></span><br><span class="line">    mymap[<span class="string">&quot;李四&quot;</span>] = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改map容器已存储键值对中，指定键对应的值</span></span><br><span class="line">    mymap[<span class="string">&quot;张三&quot;</span>] = <span class="number">30</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>利用insert()成员函数，实现插入操作</p>
<p>(1) 不指定插入位置，直接将键值对添加到 map 容器中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个空 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; mymap;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个真实存在的键值对变量</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; p = &#123; <span class="string">&quot;李四&quot;</span>,<span class="number">20</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行插入操作</span></span><br><span class="line">	mymap.insert(p);</span><br></pre></td></tr></table></figure>
<p>(2) 向 map 容器的指定位置插入新键值对</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建并初始化set容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; myset;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个真实存在的键值对变量</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; p = &#123; <span class="string">&quot;李四&quot;</span>,<span class="number">20</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定要插入的位置</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator it = mymap.begin();</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行插入操作</span></span><br><span class="line">	mymap.insert(it,p);</span><br></pre></td></tr></table></figure>
<p>(3) 向当前 map 容器中插入其它 map 容器指定区域内的所有键值对</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化一个 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;mymap&#123; &#123;<span class="string">&quot;张三&quot;</span>, <span class="number">10</span>&#125;,&#123;<span class="string">&quot;李四&quot;</span>, <span class="number">20</span>&#125;,&#123;<span class="string">&quot;王五&quot;</span>, <span class="number">30</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个空 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;copymap;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定插入区域</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator first = ++mymap.begin();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator last = mymap.end();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将&lt;first,last&gt;区域内的键值对插入到 copymap 中，操作完成后，copymap中的元素为：&#123;&quot;李四&quot;, 20&#125;,&#123;&quot;王五&quot;, 30&#125;</span></span><br><span class="line">	copymap.insert(first, last);</span><br></pre></td></tr></table></figure>
<p>(4) insert() 方法还允许一次向 map 容器中插入多个键值对</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个空 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; mymap;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向 mymap 容器中添加 3 个键值对</span></span><br><span class="line">    mymap.insert(&#123; &#123;<span class="string">&quot;张三&quot;</span>, <span class="number">10</span>&#125;,&#123;<span class="string">&quot;李四&quot;</span>, <span class="number">20</span>&#125;,&#123;<span class="string">&quot;王五&quot;</span>, <span class="number">30</span>&#125; &#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>set容器也属于关联式容器，其存储的都是用<code>pair</code>类模板创建的键值对。和map容器不同的是，使用 set 容器存储的各个键值对，要求键 key 和值 value 必须相等。这意味着当使用 set 容器存储键值对时，只需要为其提供各键值对中的 value 值（也就是 key 的值）即可。set容器也会自行根据键的大小对存储的键值对进行排序。注意到，set容器中各键值对的键 key 和值 value 是相等的，根据 key 排序，也就等价为根据 value 排序。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>,                        // 键 <span class="title">key</span> 和值 <span class="title">value</span> 的类型</span></span><br><span class="line"><span class="class">           <span class="keyword">class</span> <span class="title">Compare</span> =</span> less&lt;T&gt;,        <span class="comment">// 指定 set 容器内部的排序规则</span></span><br><span class="line">           <span class="class"><span class="keyword">class</span> <span class="title">Alloc</span> =</span> allocator&lt;T&gt;      <span class="comment">// 指定分配器对象的类型</span></span><br><span class="line">           &gt; <span class="class"><span class="keyword">class</span> <span class="title">set</span>;</span></span><br></pre></td></tr></table></figure>
<h4 id="创建set容器的几种方式"><a href="#创建set容器的几种方式" class="headerlink" title="创建set容器的几种方式"></a>创建set容器的几种方式</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; myset;<span class="comment">//创建一个空的set容器</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; myset&#123;<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;王五&quot;</span>&#125;;<span class="comment">//创建set容器的同时，对其初始化</span></span><br></pre></td></tr></table></figure>
<h4 id="set的主要函数"><a href="#set的主要函数" class="headerlink" title="set的主要函数"></a>set的主要函数</h4><table>
<thead>
<tr>
<th align="center"><strong>函数成员</strong></th>
<th align="center"><strong>函数功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin()</td>
<td align="center">返回指向容器中第一个(已排好序的第一个)元素的双向迭代器。</td>
</tr>
<tr>
<td align="center">end()</td>
<td align="center">返回指向容器最后一个元素（已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。</td>
</tr>
<tr>
<td align="center">find(val)</td>
<td align="center">在 set 容器中查找值为 val 的元素，如果成功找到，则返回指向该元素的双向迭代器；反之，则返回和 end() 方法一样的迭代器。</td>
</tr>
<tr>
<td align="center">empty()</td>
<td align="center">若容器为空，则返回 true；否则 false。</td>
</tr>
<tr>
<td align="center">size()</td>
<td align="center">返回当前 set 容器中存有键值对的个数。</td>
</tr>
<tr>
<td align="center">insert()</td>
<td align="center">向 set 容器中插入键值对。</td>
</tr>
<tr>
<td align="center">erase()</td>
<td align="center">删除 set 容器中存储的元素。</td>
</tr>
<tr>
<td align="center">emplace()</td>
<td align="center">在当前 set 容器中的指定位置直接构造新元素。其效果和 insert() 一样，但效率更高。</td>
</tr>
<tr>
<td align="center">count(val)</td>
<td align="center">在当前 set 容器中，查找值为 val 的元素的个数，并返回。注意，由于 set 容器中各元素的值是唯一的，因此该函数的返回值最大为 1</td>
</tr>
</tbody></table>
<h4 id="set容器插入数据的几种方式"><a href="#set容器插入数据的几种方式" class="headerlink" title="set容器插入数据的几种方式"></a>set容器插入数据的几种方式</h4><p> 利用insert()成员函数，实现插入操作</p>
<p>(1) 不指定插入位置，直接将键值对添加到 map 容器中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建并初始化set容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; myset;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行插入操作</span></span><br><span class="line">	myset.insert(str);</span><br></pre></td></tr></table></figure>
<p>(2) 将新元素插入到 set 容器中的具体位置</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建并初始化set容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; myset;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行插入操作</span></span><br><span class="line">    myset.insert(myset.begin(),str);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，使用 insert() 方法将目标元素插入到 set 容器指定位置后，如果该元素破坏了容器内部的有序状态，set 容器还会自行对新元素的位置做进一步调整。也就是说，insert() 方法中指定新元素插入的位置，并不一定就是该元素最终所处的位置。</p>
</blockquote>
<p>(3) insert() 方法还允许一次向 set 容器中插入多个键值对</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个空 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; myset;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向 mymap 容器中添加 3 个键值对</span></span><br><span class="line">    myset.insert(&#123; <span class="string">&quot;张三&quot;</span>,<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;王五&quot;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="set容器中删除元素"><a href="#set容器中删除元素" class="headerlink" title="set容器中删除元素"></a>set容器中删除元素</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建并初始化 set 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;myset&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除 set 容器中值为 val 的元素</span></span><br><span class="line">	<span class="keyword">int</span> num = myset.erase(<span class="number">2</span>); <span class="comment">//删除元素 2，myset=&#123;1,3,4,5&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除 position 迭代器指向的元素</span></span><br><span class="line">	<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = myset.erase(myset.begin()); <span class="comment">//删除元素 1，myset=&#123;3,4,5&#125;</span></span><br><span class="line"><span class="comment">//删除 [first,last) 区间内的所有元素</span></span><br><span class="line">	<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator iter2 = myset.erase(myset.begin(), --myset.end());<span class="comment">//删除元素 3,4，myset=&#123;5&#125;</span></span><br></pre></td></tr></table></figure>
<p>注意到第一种方法删除元素，返回的是set容器中剩余元素的个数，而后两种方法删除元素，返回的是的迭代器，指向新 set 容器中最后一个元素之后的位置</p>
<h2 id="无序关联式容器"><a href="#无序关联式容器" class="headerlink" title="无序关联式容器"></a>无序关联式容器</h2><p>和关联式容器一样，无序容器也使用键值对（<code>pair</code>类型）的方式存储数据。但两者之间有着本质上的区别，关联式容器的底层实现采用的树存储结构，更确切的说是红黑树结构，而无序容器的底层实现采用的是哈希表的存储结构。</p>
<blockquote>
<p>C++ STL 底层采用哈希表实现无序容器时，会将所有数据存储到一整块连续的内存空间中，并且当数据存储位置发生冲突时，解决方法选用的是“链地址法”</p>
</blockquote>
<p>基于底层实现采用了不同的数据结构，因此和关联式容器相比，无序容器具有以下 2 个特点：</p>
<ol>
<li>无序容器内部存储的键值对是无序的，各键值对的存储位置取决于该键值对中的键，</li>
<li>和关联式容器相比，无序容器擅长通过指定键查找对应的值（平均时间复杂度为 O(1)）；但对于使用迭代器遍历容器中存储的元素，无序容器的执行效率则不如关联式容器。</li>
</ol>
<hr>
<h3 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h3><p>unordered_map容器和map容器一样，以键值对（<code>pair</code>类型）的形式存储数据，存储的各个键值对的键互不相同且不允许被修改。但由于unordered_map容器底层采用的是哈希表存储结构，该结构本身不具有对数据的排序功能，所以此容器内部不会自行对存储的键值对进行排序。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">Key</span>,                        //键值对中键的类型</span></span><br><span class="line"><span class="class">           <span class="keyword">class</span> <span class="title">T</span>,                          //键值对中值的类型</span></span><br><span class="line"><span class="class">           <span class="keyword">class</span> <span class="title">Hash</span> =</span> hash&lt;Key&gt;,           <span class="comment">//容器内部存储键值对所用的哈希函数</span></span><br><span class="line">           <span class="class"><span class="keyword">class</span> <span class="title">Pred</span> =</span> equal_to&lt;Key&gt;,       <span class="comment">//判断各个键值对键相同的规则</span></span><br><span class="line">           <span class="class"><span class="keyword">class</span> <span class="title">Alloc</span> =</span> allocator&lt; <span class="built_in">pair</span>&lt;<span class="keyword">const</span> Key,T&gt; &gt;  <span class="comment">// 指定分配器对象的类型</span></span><br><span class="line">           &gt; <span class="class"><span class="keyword">class</span> <span class="title">unordered_map</span>;</span></span><br></pre></td></tr></table></figure>
<h4 id="创建unordered-map容器的几种方式"><a href="#创建unordered-map容器的几种方式" class="headerlink" title="创建unordered_map容器的几种方式"></a>创建unordered_map容器的几种方式</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; umap;<span class="comment">//创建一个空的unordered_map容器</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; umap&#123;&#123;<span class="string">&quot;张三&quot;</span>, <span class="number">10</span>&#125;,&#123;<span class="string">&quot;李四&quot;</span>, <span class="number">20</span>&#125;&#125;;;<span class="comment">//创建unordered_map容器的同时，对其初始化</span></span><br></pre></td></tr></table></figure>
<h4 id="unordered-map的主要函数"><a href="#unordered-map的主要函数" class="headerlink" title="unordered_map的主要函数"></a>unordered_map的主要函数</h4><table>
<thead>
<tr>
<th align="center"><strong>函数成员</strong></th>
<th align="center"><strong>函数功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin()</td>
<td align="center">返回指向容器中第一个键值对的正向迭代器。</td>
</tr>
<tr>
<td align="center">end()</td>
<td align="center">返回指向容器中最后一个键值对之后位置的正向迭代器。</td>
</tr>
<tr>
<td align="center">find(key)</td>
<td align="center">查找以 key 为键的键值对，如果找到，则返回一个指向该键值对的正向迭代器；反之，则返回一个指向容器中最后一个键值对之后位置的迭代器（如果 end() 方法返回的迭代器）。</td>
</tr>
<tr>
<td align="center">empty()</td>
<td align="center">若容器为空，则返回 true；否则 false。</td>
</tr>
<tr>
<td align="center">size()</td>
<td align="center">返回当前容器中存有键值对的个数。</td>
</tr>
<tr>
<td align="center">insert()</td>
<td align="center">向容器中添加新键值对。</td>
</tr>
<tr>
<td align="center">erase()</td>
<td align="center">删除指定键值对。</td>
</tr>
<tr>
<td align="center">count(key)</td>
<td align="center">在容器中查找以 key 键的键值对的个数。</td>
</tr>
<tr>
<td align="center">operator[key]</td>
<td align="center">该模板类中重载了 [] 运算符，其功能是可以向访问数组中元素那样，只要给定某个键值对的键 key，就可以获取该键对应的值。注意，如果当前容器中没有以 key 为键的键值对，则其会使用该键向当前容器中插入一个新键值对。</td>
</tr>
<tr>
<td align="center">at(key)</td>
<td align="center">返回容器中存储的键 key 对应的值，如果 key 不存在，则会抛出 out_of_range 异常。</td>
</tr>
</tbody></table>
<h4 id="unordered-map获取元素的几种方法"><a href="#unordered-map获取元素的几种方法" class="headerlink" title="unordered_map获取元素的几种方法"></a>unordered_map获取元素的几种方法</h4><ol>
<li><p>unordered_map 容器类模板中，实现了对 [ ] 运算符的重载，使得我们可以像“利用下标访问普通数组中元素”那样，通过目标键值对的键获取到该键对应的值。</p>
<p>需要注意的是，如果当前容器中并没有存储以 [ ] 运算符内指定的元素作为键的键值对，则此时 [ ] 运算符的功能将转变为：向当前容器中添加以目标元素为键的键值对。</p>
<blockquote>
<p>当 [ ] 运算符位于赋值号（=）右侧时，则新添加键值对的键为 [ ] 运算符内的元素，其值为键值对要求的值类型的默认值（string 类型默认值为空字符串）；</p>
<p>当 [ ] 运算符位于赋值号（=）左侧时，则新添加键值对的键为 [ ] 运算符内的元素，其值为赋值号右侧的元素。</p>
</blockquote>
</li>
<li><p>还可以使用 at() 成员方法。</p>
<p>和第一种方法相比，at() 成员方法也需要根据指定的键，才能从容器中找到该键对应的值；不同之处在于，如果在当前容器中查找失败，该方法不会向容器中添加新的键值对，而是直接抛出 <code>out_of_range</code> 异常。</p>
</li>
<li><p>unordered_map 模板中还提供了 find() 成员方法</p>
<p>通过 find() 方法得到的是一个正向迭代器，该迭代器的指向分以下 2 种情况：</p>
<p>当 find() 方法成功找到以指定元素作为键的键值对时，其返回的迭代器就指向该键值对；</p>
<p>当 find() 方法查找失败时，其返回的迭代器和 end() 方法返回的迭代器一样，指向容器中最后一个键值对之后的位置。</p>
</li>
</ol>
<hr>
<h3 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h3><p>总的来说，unordered_set 容器具有以下几个特性：</p>
<ol>
<li>不再以键值对的形式存储数据，而是直接存储数据的值；</li>
<li>容器内部存储的各个元素的值都互不相等，且不能被修改。</li>
<li>不会对内部存储的数据进行排序</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">Key</span>,            //容器中存储元素的类型</span></span><br><span class="line"><span class="class">           <span class="keyword">class</span> <span class="title">Hash</span> =</span> hash&lt;Key&gt;,    <span class="comment">//确定元素存储位置所用的哈希函数</span></span><br><span class="line">           <span class="class"><span class="keyword">class</span> <span class="title">Pred</span> =</span> equal_to&lt;Key&gt;,   <span class="comment">//判断各个元素是否相等所用的函数</span></span><br><span class="line">           <span class="class"><span class="keyword">class</span> <span class="title">Alloc</span> =</span> allocator&lt;Key&gt;   <span class="comment">//指定分配器对象的类型</span></span><br><span class="line">           &gt; <span class="class"><span class="keyword">class</span> <span class="title">unordered_set</span>;</span></span><br></pre></td></tr></table></figure>
<h4 id="创建unordered-set容器的几种方式"><a href="#创建unordered-set容器的几种方式" class="headerlink" title="创建unordered_set容器的几种方式"></a>创建unordered_set容器的几种方式</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; uset;<span class="comment">//创建一个空的unordered_set容器</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; uset&#123;<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;王五&quot;</span>&#125;;<span class="comment">//创建unordered_set容器的同时，对其初始化</span></span><br></pre></td></tr></table></figure>
<h4 id="unordered-set的主要函数"><a href="#unordered-set的主要函数" class="headerlink" title="unordered_set的主要函数"></a>unordered_set的主要函数</h4><table>
<thead>
<tr>
<th align="center"><strong>函数成员</strong></th>
<th align="center"><strong>函数功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin()</td>
<td align="center">返回指向容器中第一个键值对的正向迭代器。</td>
</tr>
<tr>
<td align="center">end()</td>
<td align="center">返回指向容器中最后一个键值对之后位置的正向迭代器。</td>
</tr>
<tr>
<td align="center">find(key)</td>
<td align="center">查找以值为 key 的元素，如果找到，则返回一个指向该元素的正向迭代器；反之，则返回一个指向容器中最后一个元素之后位置的迭代器（如果 end() 方法返回的迭代器）。</td>
</tr>
<tr>
<td align="center">empty()</td>
<td align="center">若容器为空，则返回 true；否则 false。</td>
</tr>
<tr>
<td align="center">size()</td>
<td align="center">返回当前容器中存有元素的个数。</td>
</tr>
<tr>
<td align="center">insert()</td>
<td align="center">向容器中添加新元素。</td>
</tr>
<tr>
<td align="center">erase()</td>
<td align="center">删除指定元素。</td>
</tr>
<tr>
<td align="center">count(key)</td>
<td align="center">在容器中查找值为 key 的元素的个数。</td>
</tr>
</tbody></table>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://c.biancheng.net/stl/" title="STL教程：C++ STL快速入门">STL教程：C++ STL快速入门</a> , <strong>[ C语言中文网 ]</strong></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
</search>
